// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: authentication/v1alpha2/policy.proto

// This package defines user-facing authentication policy.

package v1alpha2

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	v1beta1 "istio.io/api/common/v1beta1"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// $hide_from_docs
// AuthenticationPolicy describes how a request will be authenticated for the
// workload(s) it is attached to. It basically contains:
// - Workload selector: defines the criteria used to select a specific set of
// pods/VMs on which the authentication policy should be applied.
// - Authenticator rules: defines when and what a particular `authenticator`
// (or authenticators) will be activated.
// If more than one rules are activated, all of them (authenticators) will be
// run, and the results are combined in a AND semantic.
// Each authenticator may set `source.principal` or `request.auth.principal`
// attribute or both (see `Authenticator` for details). If two (or more)
// authenticators that set the same principal are used, the last one will
// overwrite the others.
//
// Examples:
//
// - Policy that enable mTLS for all workloads in the namespace scope of the
// policy. Note that the name of the policy is `default` and workload
// selector block is empty.
//
// ```
// apiVersion: authentication.isio.io/v1alpha2
// metadata:
//   name: default
//   namespace: foo
// spec:
//   rules:
//   - authenticator:
//      use: "mtls-strict"
// ```
//
// - Policy for workloads that match label `app=foo`. This policy enables JWT
// authentication for all request to that workload.
// ```
// apiVersion: authentication.isio.io/v1alpha2
// metadata:
//   name: jwt-example
//   namespace: foo
// spec:
//   workloadSelector:
//     matchLabels:
//       app: foo
//   rules:
//   - authenticator:
//     - use: "jwt-example"
// ```
//
// - Similar as above, but the whole authenticator spec is defined inline.
//
// ```
// apiVersion: authentication.isio.io/v1alpha2
// metadata:
//   name: inline-jwt-example
//   namespace: foo
// spec:
//   rules:
//   - authenticator:
//     - override:
//         jwt:
//           issuer: "https://securetoken.google.com"
//           audiences:
//           - "productpage"
//           jwksUri: "https://www.googleapis.com/oauth2/v1/certs"
// ```
//
// - Policy that requires both mTLS and end user credentials JWT on all requests.
//
// ```
// apiVersion: authentication.isio.io/v1alpha2
// metadata:
//   name: jwt-and-mtls-example
//   namespace: foo
// spec:
//   workloadSelector:
//     matchLabels:
//       app: foo
//   rules:
//   - authenticator:
//     - use: mtls-strict
//   - authenticator:
//     - use: "jwt-example"
// ```
//
// - Similar as above, but on port 8080 only.
//
// ```
// apiVersion: authentication.isio.io/v1alpha2
// metadata:
//   name: mtls-and-jwt-example
//   namespace: foo
// spec:
//   workloadSelector:
//     matchLabels:
//       app: foo
//   rules:
//   - match:
//     - port: 8080
//     authenticator:
//       use: mtls-strict
//   - match:
//     - port: 8080
//     authenticator:
//     - use: "jwt-example"
// ```
//
// - Policy that set mTLS for all requests, plus JWT for `/create` URI.
//
// ```
// apiVersion: authentication.isio.io/v1alpha2
// metadata:
//   name: mtls-and-conditional-jwt-example
//   namespace: foo
// spec:
//   workloadSelector:
//     matchLabels:
//       app: foo
//   rules:
//   - authenticator:
//       use: mtls-strict
//   - match:
//       uri:
//       - exact: /create
//     authenticator:
//     - use: "jwt-example"
// ```
//
// - Policy that set mTLS and JWT for all requests, except to port 3333
//
// ```
// apiVersion: authentication.isio.io/v1alpha2
// metadata:
//   name: exclude-jwt-and-mtls-example
//   namespace: foo
// spec:
//   workloadSelector:
//     matchLabels:
//       app: foo
//   rules:
//   - not_match:
//     - port: 3333
//     authenticator:
//       use: mtls-strict
//   - not_match:
//     - port: 3333
//     authenticator:
//     - use: "jwt-example"
// ```
//
// - Policy that set mTLS or JWT for all requests to port 8080.
//
// ```
// apiVersion: authentication.isio.io/v1alpha2
// metadata:
//   name: jwt-or-mtls-example
//   namespace: foo
// spec:
//   workloadSelector:
//     matchLabels:
//       app: foo
//   rules:
//   - match:
//     - port: 8080
//     authenticator:
//     - use: mtls-strict
//     - use: jwt-example
// ```
type AuthenticationPolicy struct {
	// Criteria used to select the specific set of pods/VMs on which this
	// authentication policy should be applied. If omitted, the authentication policy
	// be applied to all workload instances in the same namespace.
	Selector *v1beta1.Selector `protobuf:"bytes,1,opt,name=selector,proto3" json:"selector,omitempty"`
	// Rules specify when and what authenticators should be used for authentication.
	// Each rule contains (match) conditions. If the conditions are
	// satisfied, the associated authenticator in the rule will be used to
	//authenticate the request. This has AND-semantic, which means if more than
	// one rule meet the conditions, request is allowed if and only if all of
	// activated authenticator succeed.
	Rules                []*AuthenticatorRule `protobuf:"bytes,2,rep,name=rules,proto3" json:"rules,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *AuthenticationPolicy) Reset()         { *m = AuthenticationPolicy{} }
func (m *AuthenticationPolicy) String() string { return proto.CompactTextString(m) }
func (*AuthenticationPolicy) ProtoMessage()    {}
func (*AuthenticationPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_de35128e1eb23de7, []int{0}
}
func (m *AuthenticationPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthenticationPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthenticationPolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthenticationPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthenticationPolicy.Merge(m, src)
}
func (m *AuthenticationPolicy) XXX_Size() int {
	return m.Size()
}
func (m *AuthenticationPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthenticationPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_AuthenticationPolicy proto.InternalMessageInfo

func (m *AuthenticationPolicy) GetSelector() *v1beta1.Selector {
	if m != nil {
		return m.Selector
	}
	return nil
}

func (m *AuthenticationPolicy) GetRules() []*AuthenticatorRule {
	if m != nil {
		return m.Rules
	}
	return nil
}

// $hide_from_docs
// AuthenticatorRule specifies the conditions, if any, and the authenticator
// that will be run if the conditions are met to authenticate the request. If //`match` is not defined, the specified authenticators will be used on all
// requests. Note that, if the authenticator operates on L3/4 (e.g mTLS), then
// HTTP match conditions cannot be used (validation will reject the policy).
// Examples:
// - Rule to that matches all requests and then enable mTLS
// ```
// authenticators:
// - use: "mtls-strict"
// ```
//
// - Rule to require mTLS *or* JWT
// ```
// authenticators:
// - use: "mtls-strict"
// - use: "jwt-my-example"
// ```
//
// - Rule that requires mTLS only on port 8080:
//
// ```
// match
// - port: 8080
// authenticators:
// - use: "mtls-strict"
// ```
//
// - Rule that requires JWT except when request path is '/healthz'
//
// ```
// not_match:
// - uri:
//     exact: '/healthz'
// authenticators:
// - use: "jwt-my-example"
// ```
//
// - Rule that requires JWT on port 8080 or 80, except on path '/healthz' (for
// any ports)
//
// ```
// match:
// - port: 8080
// - port: 80
// not_match:
// - uri:
//     exact: '/healthz'
// authenticators:
// - use: "jwt-my-example"
// ```
//
// - Rule that requires JWT on port 8080 or 80, except on path '/healthz' for
// port 80.
//
// ```
// match:
// - port: 8080
// - port: 80
// not_match:
// - port: 80
//   uri:
//     exact: '/healthz'
// authenticators:
// - use: "jwt-my-example"
// ```
type AuthenticatorRule struct {
	// Defines the conditions that the authenticators below should be used. All
	// conditions inside a single match block have AND semantics, while the list of
	// match blocks have OR semantics.
	// If one authenticator (or more) operate on L3/4 (e.g mTLS), then
	// the match block cannot use L7 (HTTP) conditions.
	Match []*Match `protobuf:"bytes,1,rep,name=match,proto3" json:"match,omitempty"`
	// Negative match conditions. Each `match` block is evaluated as usual, but the result is inverted
	// then ANDed together. The final result is then AND with the (positive) match conditions above.
	NotMatch []*Match `protobuf:"bytes,2,rep,name=not_match,json=notMatch,proto3" json:"not_match,omitempty"`
	// If the `match` conditions are satisfied, these authenticators will be tried in order, and stop
	// on the first one that successes. If none of these successed, the reuquest will be denied
	// (authentication failed).
	Authenticators       []*AuthenticatorRef `protobuf:"bytes,3,rep,name=authenticators,proto3" json:"authenticators,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *AuthenticatorRule) Reset()         { *m = AuthenticatorRule{} }
func (m *AuthenticatorRule) String() string { return proto.CompactTextString(m) }
func (*AuthenticatorRule) ProtoMessage()    {}
func (*AuthenticatorRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_de35128e1eb23de7, []int{1}
}
func (m *AuthenticatorRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthenticatorRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthenticatorRule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthenticatorRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthenticatorRule.Merge(m, src)
}
func (m *AuthenticatorRule) XXX_Size() int {
	return m.Size()
}
func (m *AuthenticatorRule) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthenticatorRule.DiscardUnknown(m)
}

var xxx_messageInfo_AuthenticatorRule proto.InternalMessageInfo

func (m *AuthenticatorRule) GetMatch() []*Match {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *AuthenticatorRule) GetNotMatch() []*Match {
	if m != nil {
		return m.NotMatch
	}
	return nil
}

func (m *AuthenticatorRule) GetAuthenticators() []*AuthenticatorRef {
	if m != nil {
		return m.Authenticators
	}
	return nil
}

// $hide_from_docs
// AuthenticatorRef refers to the authenticator to run.
//
// Example (see AuthenticationPolicy to see in the full context)
// - Use Istio stock mtls-strict
//
// ```
// use: "mtls-strict"
// ```
//
// - Use Istio stock mtls-strict with modification on the output principal
// ```
// use: "mtls-strict"
// override:
//   principal_type: SOURCE
// ```
type AuthenticatorRef struct {
	// REQUIRE. Refer to the name of the authenticator to run. The authenticator spec is defined in
	// the `authenticator` kind CR with that name.
	Use                  string   `protobuf:"bytes,1,opt,name=use,proto3" json:"use,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AuthenticatorRef) Reset()         { *m = AuthenticatorRef{} }
func (m *AuthenticatorRef) String() string { return proto.CompactTextString(m) }
func (*AuthenticatorRef) ProtoMessage()    {}
func (*AuthenticatorRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_de35128e1eb23de7, []int{2}
}
func (m *AuthenticatorRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthenticatorRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthenticatorRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthenticatorRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthenticatorRef.Merge(m, src)
}
func (m *AuthenticatorRef) XXX_Size() int {
	return m.Size()
}
func (m *AuthenticatorRef) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthenticatorRef.DiscardUnknown(m)
}

var xxx_messageInfo_AuthenticatorRef proto.InternalMessageInfo

func (m *AuthenticatorRef) GetUse() string {
	if m != nil {
		return m.Use
	}
	return ""
}

// $hide_from_docs
// Match specifies a set of criterion to be met in order for the rule to be applied.
// For example, the following restricts mTLS being applied only on port 8080, and JWT
// authentication if the request path starts with /get. Conditions inside the match block have
// AND sematic.
//
// Examples:
//
// - Match condtions for port 8080
//
// ```
//   - match
//       port: 8080
// ```
//
// - Match condtions for port 8080, and request URI with prefix '/create'
//
// ```
//   - match
//       port: 8080
//       uri:
//         prefix: '/create'
// ```
// Note: this is a simple version of [`HTTPMatchRequest`](networking/v1alpha3/virtual_service.proto)
//
type Match struct {
	// Workload port to match. If not specified, it matches to any port number.
	Port uint32 `protobuf:"varint,1,opt,name=port,proto3" json:"port,omitempty"`
	// URI to match.
	// values are case-sensitive and formatted as follows:
	//
	// - `exact: "value"` for exact string match
	//
	// - `prefix: "value"` for prefix-based match
	//
	// - `regex: "value"` for ECMAscript style regex-based match
	//
	Uri                  *v1beta1.StringMatch `protobuf:"bytes,3,opt,name=uri,proto3" json:"uri,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Match) Reset()         { *m = Match{} }
func (m *Match) String() string { return proto.CompactTextString(m) }
func (*Match) ProtoMessage()    {}
func (*Match) Descriptor() ([]byte, []int) {
	return fileDescriptor_de35128e1eb23de7, []int{3}
}
func (m *Match) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Match) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Match.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Match) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Match.Merge(m, src)
}
func (m *Match) XXX_Size() int {
	return m.Size()
}
func (m *Match) XXX_DiscardUnknown() {
	xxx_messageInfo_Match.DiscardUnknown(m)
}

var xxx_messageInfo_Match proto.InternalMessageInfo

func (m *Match) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *Match) GetUri() *v1beta1.StringMatch {
	if m != nil {
		return m.Uri
	}
	return nil
}

func init() {
	proto.RegisterType((*AuthenticationPolicy)(nil), "istio.authentication.v1alpha2.AuthenticationPolicy")
	proto.RegisterType((*AuthenticatorRule)(nil), "istio.authentication.v1alpha2.AuthenticatorRule")
	proto.RegisterType((*AuthenticatorRef)(nil), "istio.authentication.v1alpha2.AuthenticatorRef")
	proto.RegisterType((*Match)(nil), "istio.authentication.v1alpha2.Match")
}

func init() {
	proto.RegisterFile("authentication/v1alpha2/policy.proto", fileDescriptor_de35128e1eb23de7)
}

var fileDescriptor_de35128e1eb23de7 = []byte{
	// 338 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x92, 0xc1, 0x4a, 0xf3, 0x40,
	0x14, 0x85, 0x99, 0xe6, 0xef, 0x4f, 0x7b, 0x8b, 0x52, 0x07, 0x17, 0xa1, 0xd0, 0x50, 0x43, 0x16,
	0x5d, 0x4d, 0x6c, 0xba, 0xeb, 0xae, 0x2e, 0xdc, 0x09, 0x65, 0x5c, 0x08, 0x6e, 0x64, 0x1a, 0x46,
	0x3b, 0x90, 0x66, 0xc2, 0xe4, 0x46, 0xf0, 0x55, 0x7c, 0x22, 0x97, 0x3e, 0x82, 0x74, 0xeb, 0x4b,
	0x48, 0x67, 0x5a, 0x69, 0x23, 0x55, 0xba, 0xbb, 0x70, 0xce, 0xf9, 0xe6, 0x5c, 0xee, 0x40, 0x24,
	0x2a, 0x5c, 0xc8, 0x1c, 0x55, 0x2a, 0x50, 0xe9, 0x3c, 0x7e, 0x1e, 0x89, 0xac, 0x58, 0x88, 0x24,
	0x2e, 0x74, 0xa6, 0xd2, 0x17, 0x56, 0x18, 0x8d, 0x9a, 0xf6, 0x55, 0x89, 0x4a, 0xb3, 0x7d, 0x2f,
	0xdb, 0x7a, 0x7b, 0xfd, 0x54, 0x2f, 0x97, 0x36, 0x3c, 0x97, 0x28, 0x46, 0x71, 0x29, 0x33, 0x99,
	0xa2, 0x36, 0x2e, 0xdd, 0xeb, 0xd5, 0xe4, 0xa5, 0xc0, 0x74, 0xe1, 0xb4, 0xf0, 0x95, 0xc0, 0xf9,
	0x74, 0x0f, 0x3b, 0xb3, 0x0f, 0xd3, 0x09, 0xb4, 0xb6, 0x18, 0x9f, 0x0c, 0xc8, 0xb0, 0x93, 0x04,
	0xcc, 0xb5, 0x70, 0x34, 0xb6, 0xa1, 0xb1, 0xdb, 0x8d, 0x8b, 0x7f, 0xfb, 0xe9, 0x35, 0x34, 0x4d,
	0x95, 0xc9, 0xd2, 0x6f, 0x0c, 0xbc, 0x61, 0x27, 0xb9, 0x64, 0xbf, 0xd6, 0x67, 0x3b, 0xef, 0x6b,
	0xc3, 0xab, 0x4c, 0x72, 0x17, 0x0f, 0x3f, 0x09, 0x9c, 0xfd, 0x10, 0xe9, 0x04, 0x9a, 0x76, 0x03,
	0x9f, 0x58, 0x7a, 0xf4, 0x07, 0xfd, 0x66, 0xed, 0xe5, 0x2e, 0x42, 0xa7, 0xd0, 0xce, 0x35, 0x3e,
	0xb8, 0x7c, 0xe3, 0x88, 0x7c, 0x2b, 0xd7, 0x68, 0x27, 0x7a, 0x07, 0xa7, 0x62, 0xb7, 0x53, 0xe9,
	0x7b, 0x96, 0x13, 0x1f, 0xb5, 0xa5, 0x7c, 0xe4, 0x35, 0x4c, 0x18, 0x41, 0xb7, 0xee, 0xa1, 0x5d,
	0xf0, 0xaa, 0x52, 0xda, 0x03, 0xb4, 0xf9, 0x7a, 0x0c, 0x67, 0xd0, 0x74, 0x3d, 0x28, 0xfc, 0x2b,
	0xb4, 0x41, 0xab, 0x9d, 0x70, 0x3b, 0xd3, 0x31, 0x78, 0x95, 0x51, 0xbe, 0x67, 0xef, 0x75, 0x71,
	0xe0, 0x5e, 0x68, 0x54, 0xfe, 0xe4, 0xb6, 0x5a, 0xbb, 0xaf, 0x92, 0xb7, 0x55, 0x40, 0xde, 0x57,
	0x01, 0xf9, 0x58, 0x05, 0xe4, 0x3e, 0x72, 0x21, 0xa5, 0x63, 0x51, 0xa8, 0xf8, 0xc0, 0xef, 0x9c,
	0xff, 0xb7, 0xbf, 0x67, 0xfc, 0x15, 0x00, 0x00, 0xff, 0xff, 0x4f, 0x53, 0x8c, 0xeb, 0xbf, 0x02,
	0x00, 0x00,
}

func (m *AuthenticationPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthenticationPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Selector != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.Selector.Size()))
		n1, err1 := m.Selector.MarshalTo(dAtA[i:])
		if err1 != nil {
			return 0, err1
		}
		i += n1
	}
	if len(m.Rules) > 0 {
		for _, msg := range m.Rules {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPolicy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AuthenticatorRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthenticatorRule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Match) > 0 {
		for _, msg := range m.Match {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPolicy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.NotMatch) > 0 {
		for _, msg := range m.NotMatch {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPolicy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Authenticators) > 0 {
		for _, msg := range m.Authenticators {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintPolicy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AuthenticatorRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthenticatorRef) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Use) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(len(m.Use)))
		i += copy(dAtA[i:], m.Use)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Match) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Match) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Port != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.Port))
	}
	if m.Uri != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.Uri.Size()))
		n2, err2 := m.Uri.MarshalTo(dAtA[i:])
		if err2 != nil {
			return 0, err2
		}
		i += n2
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintPolicy(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *AuthenticationPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Selector != nil {
		l = m.Selector.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AuthenticatorRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Match) > 0 {
		for _, e := range m.Match {
			l = e.Size()
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	if len(m.NotMatch) > 0 {
		for _, e := range m.NotMatch {
			l = e.Size()
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	if len(m.Authenticators) > 0 {
		for _, e := range m.Authenticators {
			l = e.Size()
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AuthenticatorRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Use)
	if l > 0 {
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Match) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Port != 0 {
		n += 1 + sovPolicy(uint64(m.Port))
	}
	if m.Uri != nil {
		l = m.Uri.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovPolicy(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozPolicy(x uint64) (n int) {
	return sovPolicy(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AuthenticationPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthenticationPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthenticationPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Selector == nil {
				m.Selector = &v1beta1.Selector{}
			}
			if err := m.Selector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, &AuthenticatorRule{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthenticatorRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthenticatorRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthenticatorRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Match = append(m.Match, &Match{})
			if err := m.Match[len(m.Match)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotMatch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NotMatch = append(m.NotMatch, &Match{})
			if err := m.NotMatch[len(m.NotMatch)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authenticators", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authenticators = append(m.Authenticators, &AuthenticatorRef{})
			if err := m.Authenticators[len(m.Authenticators)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthenticatorRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthenticatorRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthenticatorRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Use", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Use = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Match) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Match: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Match: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Uri == nil {
				m.Uri = &v1beta1.StringMatch{}
			}
			if err := m.Uri.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPolicy(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPolicy
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthPolicy
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowPolicy
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipPolicy(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthPolicy
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthPolicy = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPolicy   = fmt.Errorf("proto: integer overflow")
)
