// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: authentication/v1alpha2/policy.proto

// This package defines user-facing authentication policy.

package v1alpha2

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	v1beta1 "istio.io/api/common/v1beta1"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// $hide_from_docs
// AuthenticationPolicy describes how a request will be authenticated for the
// workload(s) it is attached to. It basically contains:
// - Workload selector: defines the criteria used to select a specific set of
// pods/VMs on which the authentication policy should be applied.
// - Authenticator rules: defines when and what a particular `authenticator`
// (or authenticators) will be activated.
// If more than one rules are activated, all of them (authenticators) will be
// run, and the results are combined in a AND semantic.
// Each authenticator may set `source.principal` or `request.auth.principal`
// attribute or both (see `Authenticator` for details). If two (or more)
// authenticators that set the same principal are used, the last one will
// overwrite the others.
//
// Examples:
//
// - Policy that enable mTLS for all workloads in the namespace scope of the
// policy. Note that the name of the policy is `default` and workload
// selector block is empty.
//
// ```
// apiVersion: authentication.isio.io/v1alpha2
// metadata:
//   name: default
//   namespace: foo
// spec:
//   rules:
//   - authenticator:
//      use: "mtls-strict"
// ```
//
// - Policy for workloads that match label `app=foo`. This policy enables JWT
// authentication for all request to that workload.
// ```
// apiVersion: authentication.isio.io/v1alpha2
// metadata:
//   name: jwt-example
//   namespace: foo
// spec:
//  selector:
//     matchLabels:
//       app: foo
//   rules:
//   - authenticator:
//     - use: "jwt-example"
// ```
//
// - Similar as above, but the whole authenticator spec is defined inline.
//
// ```
// apiVersion: authentication.isio.io/v1alpha2
// metadata:
//   name: inline-jwt-example
//   namespace: foo
// spec:
//   rules:
//   - authenticator:
//     - override:
//         jwt:
//           issuer: "https://securetoken.google.com"
//           audiences:
//           - "productpage"
//           jwksUri: "https://www.googleapis.com/oauth2/v1/certs"
// ```
//
// - Policy with partial-override authenticator parameters: the `jwt-example`
// authenticator will be used, with the `audiences` field is set to `my-audidence`:
//
// ```
// apiVersion: authentication.isio.io/v1alpha2
// metadata:
//   name: overrid-jwt-example
//   namespace: foo
// spec:
//   rules:
//   - authenticator:
//     - use: "jwt-example"
//       override:
//         jwt:
//           audiences:
//           - "my-audience"
// ```
//
// - Policy that requires both mTLS and end user credentials JWT on all requests.
//
// ```
// apiVersion: authentication.isio.io/v1alpha2
// metadata:
//   name: jwt-and-mtls-example
//   namespace: foo
// spec:
//   selector:
//     matchLabels:
//       app: foo
//   rules:
//   - authenticator:
//     - use: mtls-strict
//   - authenticator:
//     - use: "jwt-example"
// ```
//
// - Similar as above, but on port 8080 only.
//
// ```
// apiVersion: authentication.isio.io/v1alpha2
// metadata:
//   name: mtls-and-jwt-example
//   namespace: foo
// spec:
//   workloadSelector:
//     matchLabels:
//       app: foo
//   rules:
//   - match:
//       port: 8080
//     authenticator:
//       use: mtls-strict
//   - match:
//     - port: 8080
//     authenticator:
//     - use: "jwt-example"
// ```
//
// - Policy that set mTLS for all requests, plus JWT for `/create` URI.
//
// ```
// apiVersion: authentication.isio.io/v1alpha2
// metadata:
//   name: mtls-and-conditional-jwt-example
//   namespace: foo
// spec:
//   selector:
//     matchLabels:
//       app: foo
//   rules:
//   - authenticator:
//       use: mtls-strict
//   - match:
//       uri:
//       - exact: /create
//     authenticator:
//     - use: "jwt-example"
// ```
//
// - Policy that set mTLS and JWT for all requests, except to port 3333
//
// ```
// apiVersion: authentication.isio.io/v1alpha2
// metadata:
//   name: exclude-jwt-and-mtls-example
//   namespace: foo
// spec:
//   selector:
//     matchLabels:
//       app: foo
//   rules:
//   - not_match:
//     - port: 3333
//     authenticator:
//       use: mtls-strict
//   - not_match:
//     - port: 3333
//     authenticator:
//     - use: "jwt-example"
// ```
//
// - Policy that set mTLS or JWT for all requests to port 8080.
//
// ```
// apiVersion: authentication.isio.io/v1alpha2
// metadata:
//   name: jwt-or-mtls-example
//   namespace: foo
// spec:
//   workloadSelector:
//     matchLabels:
//       app: foo
//   rules:
//   - match:
//     - port: 8080
//     authenticator:
//     - use: mtls-strict
//     - use: jwt-example
// ```
type AuthenticationPolicy struct {
	// Criteria used to select the specific set of pods/VMs on which this
	// authentication policy should be applied. If omitted, the authentication policy
	// be applied to all workload instances in the same namespace.
	Selector *v1beta1.Selector `protobuf:"bytes,1,opt,name=selector,proto3" json:"selector,omitempty"`
	// Definition of authenticators that are used in the policy.
	Authenticators map[string]*Authenticator `protobuf:"bytes,2,rep,name=authenticators,proto3" json:"authenticators,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Rules specify when and what authenticators should be used for authentication.
	// Each rule contains (match) conditions. If the conditions are
	// satisfied, the associated authenticator in the rule will be used to
	//authenticate the request. This has AND-semantic, which means if more than
	// one rule meet the conditions, request is allowed if and only if all of
	// activated authenticator succeed.
	Rules                []*AuthenticatorRule `protobuf:"bytes,3,rep,name=rules,proto3" json:"rules,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *AuthenticationPolicy) Reset()         { *m = AuthenticationPolicy{} }
func (m *AuthenticationPolicy) String() string { return proto.CompactTextString(m) }
func (*AuthenticationPolicy) ProtoMessage()    {}
func (*AuthenticationPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_de35128e1eb23de7, []int{0}
}
func (m *AuthenticationPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthenticationPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthenticationPolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthenticationPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthenticationPolicy.Merge(m, src)
}
func (m *AuthenticationPolicy) XXX_Size() int {
	return m.Size()
}
func (m *AuthenticationPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthenticationPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_AuthenticationPolicy proto.InternalMessageInfo

func (m *AuthenticationPolicy) GetSelector() *v1beta1.Selector {
	if m != nil {
		return m.Selector
	}
	return nil
}

func (m *AuthenticationPolicy) GetAuthenticators() map[string]*Authenticator {
	if m != nil {
		return m.Authenticators
	}
	return nil
}

func (m *AuthenticationPolicy) GetRules() []*AuthenticatorRule {
	if m != nil {
		return m.Rules
	}
	return nil
}

type AuthenticatorRule struct {
	// Defines the conditions that the authenticators below should be used. All
	// conditions inside the match block have AND semantics.
	// If one authenticator (or more) operate on L3/4 (e.g mTLS), then
	// the match block cannot use L7 (HTTP) conditions.
	Match *Match `protobuf:"bytes,1,opt,name=match,proto3" json:"match,omitempty"`
	// If the `match` conditions are satisfied, these authenticators will be tried in order, and stop
	// on the first one that successes. If none of these successed, the reuquest will be denied
	// (authentication failed).
	FirstOf              []*AuthenticatorRef `protobuf:"bytes,2,rep,name=first_of,json=firstOf,proto3" json:"first_of,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *AuthenticatorRule) Reset()         { *m = AuthenticatorRule{} }
func (m *AuthenticatorRule) String() string { return proto.CompactTextString(m) }
func (*AuthenticatorRule) ProtoMessage()    {}
func (*AuthenticatorRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_de35128e1eb23de7, []int{1}
}
func (m *AuthenticatorRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthenticatorRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthenticatorRule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthenticatorRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthenticatorRule.Merge(m, src)
}
func (m *AuthenticatorRule) XXX_Size() int {
	return m.Size()
}
func (m *AuthenticatorRule) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthenticatorRule.DiscardUnknown(m)
}

var xxx_messageInfo_AuthenticatorRule proto.InternalMessageInfo

func (m *AuthenticatorRule) GetMatch() *Match {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *AuthenticatorRule) GetFirstOf() []*AuthenticatorRef {
	if m != nil {
		return m.FirstOf
	}
	return nil
}

// $hide_from_docs
// AuthenticatorRef refers to the authenticator to run.
//
// Example (see AuthenticationPolicy to see in the full context)
// - Use Istio stock mtls-strict
//
// ```
// firstOf:
// - authenticator: "mtls-strict"
// ```
type AuthenticatorRef struct {
	// REQUIRE. Refer to the name of the authenticator to run. The authenticator
	// spec is defined in the authenticator section of the policy.
	Authenticator        string   `protobuf:"bytes,1,opt,name=authenticator,proto3" json:"authenticator,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AuthenticatorRef) Reset()         { *m = AuthenticatorRef{} }
func (m *AuthenticatorRef) String() string { return proto.CompactTextString(m) }
func (*AuthenticatorRef) ProtoMessage()    {}
func (*AuthenticatorRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_de35128e1eb23de7, []int{2}
}
func (m *AuthenticatorRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthenticatorRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthenticatorRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthenticatorRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthenticatorRef.Merge(m, src)
}
func (m *AuthenticatorRef) XXX_Size() int {
	return m.Size()
}
func (m *AuthenticatorRef) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthenticatorRef.DiscardUnknown(m)
}

var xxx_messageInfo_AuthenticatorRef proto.InternalMessageInfo

func (m *AuthenticatorRef) GetAuthenticator() string {
	if m != nil {
		return m.Authenticator
	}
	return ""
}

// $hide_from_docs
// Match specifies a set of criterion to be met in order for the rule to be applied.
// For example, the following restricts mTLS being applied only on port 8080, and JWT
// authentication if the request path starts with /get. Conditions inside the match block have
// AND sematic.
//
// Examples:
//
// - Match condtions for port 8080
//
// ```
//   - match
//       port: 8080
// ```
//
// - Match condtions for port 8080, and request URI with prefix '/create'
//
// ```
//   - match
//       port: 8080
//       uri:
//         prefix: '/create'
// ```
// Note: this is a simple version of [`HTTPMatchRequest`](networking/v1alpha3/virtual_service.proto)
//
type Match struct {
	// Workload port to match. If not specified, it matches to any port number.
	Port uint32 `protobuf:"varint,1,opt,name=port,proto3" json:"port,omitempty"`
	// URI to match.
	// values are case-sensitive and formatted as follows:
	//
	// - `exact: "value"` for exact string match
	//
	// - `prefix: "value"` for prefix-based match
	//
	// - `regex: "value"` for ECMAscript style regex-based match
	//
	Uri                  *v1beta1.StringMatch `protobuf:"bytes,2,opt,name=uri,proto3" json:"uri,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Match) Reset()         { *m = Match{} }
func (m *Match) String() string { return proto.CompactTextString(m) }
func (*Match) ProtoMessage()    {}
func (*Match) Descriptor() ([]byte, []int) {
	return fileDescriptor_de35128e1eb23de7, []int{3}
}
func (m *Match) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Match) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Match.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Match) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Match.Merge(m, src)
}
func (m *Match) XXX_Size() int {
	return m.Size()
}
func (m *Match) XXX_DiscardUnknown() {
	xxx_messageInfo_Match.DiscardUnknown(m)
}

var xxx_messageInfo_Match proto.InternalMessageInfo

func (m *Match) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *Match) GetUri() *v1beta1.StringMatch {
	if m != nil {
		return m.Uri
	}
	return nil
}

func init() {
	proto.RegisterType((*AuthenticationPolicy)(nil), "istio.authentication.v1alpha2.AuthenticationPolicy")
	proto.RegisterMapType((map[string]*Authenticator)(nil), "istio.authentication.v1alpha2.AuthenticationPolicy.AuthenticatorsEntry")
	proto.RegisterType((*AuthenticatorRule)(nil), "istio.authentication.v1alpha2.AuthenticatorRule")
	proto.RegisterType((*AuthenticatorRef)(nil), "istio.authentication.v1alpha2.AuthenticatorRef")
	proto.RegisterType((*Match)(nil), "istio.authentication.v1alpha2.Match")
}

func init() {
	proto.RegisterFile("authentication/v1alpha2/policy.proto", fileDescriptor_de35128e1eb23de7)
}

var fileDescriptor_de35128e1eb23de7 = []byte{
	// 393 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x53, 0x4f, 0xcb, 0xd3, 0x30,
	0x18, 0xa7, 0xad, 0xd5, 0xf9, 0x8c, 0xc9, 0x8c, 0x1e, 0x4a, 0x61, 0x65, 0x96, 0x1e, 0x06, 0x4a,
	0xea, 0xba, 0xcb, 0xd8, 0xcd, 0x81, 0x0a, 0x82, 0x38, 0xe2, 0xcd, 0x8b, 0x64, 0x25, 0x75, 0xc1,
	0xae, 0x29, 0x69, 0x3a, 0xd8, 0x67, 0xf1, 0x0b, 0x79, 0xf4, 0x23, 0xc8, 0x3e, 0x87, 0x07, 0x59,
	0xd2, 0xe9, 0xba, 0x77, 0x7b, 0xdf, 0x77, 0xb7, 0xf0, 0x3c, 0xbf, 0x7f, 0xf9, 0x35, 0x85, 0x88,
	0xd6, 0x6a, 0xc5, 0x0a, 0xc5, 0x53, 0xaa, 0xb8, 0x28, 0xe2, 0xcd, 0x98, 0xe6, 0xe5, 0x8a, 0x26,
	0x71, 0x29, 0x72, 0x9e, 0x6e, 0x71, 0x29, 0x85, 0x12, 0x68, 0xc0, 0x2b, 0xc5, 0x05, 0x6e, 0x63,
	0xf1, 0x01, 0xeb, 0xbf, 0xbc, 0x24, 0x72, 0x34, 0x17, 0xd2, 0x68, 0xf9, 0x83, 0x54, 0xac, 0xd7,
	0x1a, 0xb4, 0x64, 0x8a, 0x8e, 0xe3, 0x8a, 0xe5, 0x2c, 0xfd, 0xbf, 0xf6, 0x4f, 0xd6, 0x6b, 0xaa,
	0xd2, 0x95, 0xd9, 0x85, 0x7f, 0x6c, 0x78, 0xfe, 0xa6, 0x65, 0xb5, 0xd0, 0x29, 0xd1, 0x0c, 0x3a,
	0x07, 0x19, 0xcf, 0x1a, 0x5a, 0xa3, 0x6e, 0x12, 0x60, 0x13, 0xd9, 0xa8, 0xe1, 0x46, 0x0d, 0x7f,
	0x6e, 0x50, 0xe4, 0x1f, 0x1e, 0x09, 0x78, 0xd2, 0x8a, 0x59, 0x79, 0xf6, 0xd0, 0x19, 0x75, 0x93,
	0xf7, 0xf8, 0xd6, 0x4b, 0xe3, 0x73, 0x41, 0x8e, 0x87, 0x42, 0x56, 0x6f, 0x0b, 0x25, 0xb7, 0xe4,
	0x44, 0x1e, 0xbd, 0x03, 0x57, 0xd6, 0x39, 0xab, 0x3c, 0x47, 0xfb, 0xbc, 0xbe, 0xbf, 0x8f, 0x90,
	0xa4, 0xce, 0x19, 0x31, 0x74, 0x5f, 0xc0, 0xb3, 0x33, 0x76, 0xa8, 0x0f, 0xce, 0x77, 0xb6, 0xd5,
	0x35, 0x3c, 0x26, 0xfb, 0x23, 0x9a, 0x83, 0xbb, 0xa1, 0x79, 0xcd, 0x3c, 0x5b, 0x57, 0xf3, 0xea,
	0x2a, 0x43, 0x43, 0x9d, 0xd9, 0x53, 0x2b, 0xfc, 0x61, 0xc1, 0xd3, 0x1b, 0x69, 0xd0, 0x0c, 0x5c,
	0xfd, 0x8d, 0x9a, 0xe2, 0xa3, 0x3b, 0xd4, 0x3f, 0xee, 0xb1, 0xc4, 0x50, 0xd0, 0x07, 0xe8, 0x64,
	0x5c, 0x56, 0xea, 0xab, 0xc8, 0x9a, 0xd6, 0xe3, 0xab, 0xc2, 0xb1, 0x8c, 0x3c, 0xd2, 0x02, 0x9f,
	0xb2, 0x70, 0x0a, 0xfd, 0xd3, 0x25, 0x8a, 0xa0, 0xd7, 0x2a, 0xbf, 0x69, 0xa5, 0x3d, 0x0c, 0x17,
	0xe0, 0xea, 0x54, 0x08, 0xc1, 0x83, 0x52, 0x48, 0xa5, 0x51, 0x3d, 0xa2, 0xcf, 0x68, 0x02, 0x4e,
	0x2d, 0x79, 0x53, 0xdd, 0x8b, 0x0b, 0xaf, 0x4a, 0x49, 0x5e, 0x7c, 0x33, 0x37, 0xdb, 0xa3, 0xe7,
	0xc9, 0xcf, 0x5d, 0x60, 0xfd, 0xda, 0x05, 0xd6, 0xef, 0x5d, 0x60, 0x7d, 0x89, 0x0c, 0x89, 0x8b,
	0x98, 0x96, 0x3c, 0xbe, 0xf0, 0xaf, 0x2c, 0x1f, 0xea, 0x37, 0x3e, 0xf9, 0x1b, 0x00, 0x00, 0xff,
	0xff, 0xac, 0x44, 0x36, 0xb7, 0x92, 0x03, 0x00, 0x00,
}

func (m *AuthenticationPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthenticationPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Selector != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.Selector.Size()))
		n1, err1 := m.Selector.MarshalTo(dAtA[i:])
		if err1 != nil {
			return 0, err1
		}
		i += n1
	}
	if len(m.Authenticators) > 0 {
		for k, _ := range m.Authenticators {
			dAtA[i] = 0x12
			i++
			v := m.Authenticators[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovPolicy(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovPolicy(uint64(len(k))) + msgSize
			i = encodeVarintPolicy(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintPolicy(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintPolicy(dAtA, i, uint64(v.Size()))
				n2, err2 := v.MarshalTo(dAtA[i:])
				if err2 != nil {
					return 0, err2
				}
				i += n2
			}
		}
	}
	if len(m.Rules) > 0 {
		for _, msg := range m.Rules {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintPolicy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AuthenticatorRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthenticatorRule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Match != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.Match.Size()))
		n3, err3 := m.Match.MarshalTo(dAtA[i:])
		if err3 != nil {
			return 0, err3
		}
		i += n3
	}
	if len(m.FirstOf) > 0 {
		for _, msg := range m.FirstOf {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPolicy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AuthenticatorRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthenticatorRef) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Authenticator) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(len(m.Authenticator)))
		i += copy(dAtA[i:], m.Authenticator)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Match) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Match) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Port != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.Port))
	}
	if m.Uri != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.Uri.Size()))
		n4, err4 := m.Uri.MarshalTo(dAtA[i:])
		if err4 != nil {
			return 0, err4
		}
		i += n4
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintPolicy(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *AuthenticationPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Selector != nil {
		l = m.Selector.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if len(m.Authenticators) > 0 {
		for k, v := range m.Authenticators {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPolicy(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPolicy(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPolicy(uint64(mapEntrySize))
		}
	}
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AuthenticatorRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Match != nil {
		l = m.Match.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if len(m.FirstOf) > 0 {
		for _, e := range m.FirstOf {
			l = e.Size()
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AuthenticatorRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authenticator)
	if l > 0 {
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Match) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Port != 0 {
		n += 1 + sovPolicy(uint64(m.Port))
	}
	if m.Uri != nil {
		l = m.Uri.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovPolicy(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozPolicy(x uint64) (n int) {
	return sovPolicy(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AuthenticationPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthenticationPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthenticationPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Selector == nil {
				m.Selector = &v1beta1.Selector{}
			}
			if err := m.Selector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authenticators", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Authenticators == nil {
				m.Authenticators = make(map[string]*Authenticator)
			}
			var mapkey string
			var mapvalue *Authenticator
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPolicy
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPolicy
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPolicy
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPolicy
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPolicy
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPolicy
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPolicy
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Authenticator{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPolicy(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPolicy
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Authenticators[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, &AuthenticatorRule{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthenticatorRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthenticatorRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthenticatorRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Match == nil {
				m.Match = &Match{}
			}
			if err := m.Match.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstOf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstOf = append(m.FirstOf, &AuthenticatorRef{})
			if err := m.FirstOf[len(m.FirstOf)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthenticatorRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthenticatorRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthenticatorRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authenticator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authenticator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Match) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Match: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Match: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Uri == nil {
				m.Uri = &v1beta1.StringMatch{}
			}
			if err := m.Uri.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPolicy(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPolicy
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthPolicy
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowPolicy
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipPolicy(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthPolicy
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthPolicy = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPolicy   = fmt.Errorf("proto: integer overflow")
)
